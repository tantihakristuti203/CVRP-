# -*- coding: utf-8 -*-
"""Kodingan Skripsi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bmuSO_OmZ7pTNcyeLiUIf3g7W2eQ32Pf
"""

# kodingan 1/2 dengan pengulangan crossover dengan Iterasi 200 fiks
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Read data from Excel file
filename = 'A-n80-k10.xlsx'
D = pd.read_excel(filename)
coordinates = D[['X', 'Y']].values
demands = D['Demand'].values
nodes = D['Node'].values
numvehicle = 10
vehicle_capacity = 100 # Example capacity, change as needed
depot = 0  # Depot is node 0

# Function to calculate distance between two nodes
def calculate_distance(node1, node2):
    x1, y1 = coordinates[node1]
    x2, y2 = coordinates[node2]
    return np.sqrt((x2 - x1)**2 + (y2 - y1)**2)

# Function to calculate total route distance
def calculate_route_distance(route):
    total_distance = 0
    for i in range(len(route) - 1):
        total_distance += calculate_distance(route[i], route[i + 1])
    return total_distance

# Initialize population
population_size = 100
population = []
for _ in range(population_size):
    route = np.random.permutation(len(nodes) - 1) + 1  # Assuming nodes start from 1 and exclude depot (0)
    population.append(route)

# Convert the list of arrays to a NumPy array
population = np.array(population)

# Simulated Annealing parameters
max_iterations = 400 # Maximum number of iterations
initial_temperature = 10
final_temperature = 0.001
cooling_rate = np.power(final_temperature/initial_temperature, 1/(max_iterations-1))
crossover_probability = 0.7

# Objective function
def objective_function(route):
    return calculate_route_distance(route)

# Simulated Annealing algorithm
current_solution = np.copy(population)  # Set current solution to the entire population
current_costs = np.apply_along_axis(objective_function, 1, current_solution)
best_solution_index = np.argmin(current_costs)
best_solution = np.copy(current_solution[best_solution_index])
best_cost = current_costs[best_solution_index]

temperature = initial_temperature

# Functions for various operators
def swap_operator(route):
    route_copy = route.copy()
    idx1, idx2 = np.random.choice(len(route), 2, replace=False)
    route_copy[idx1], route_copy[idx2] = route_copy[idx2], route_copy[idx1]
    return route_copy

def insertion(X, i, j):
    X_baru = X.copy()
    gen_yang_disisipkan = X[j - 1]  # Simpan nilai gen yang akan disisipkan

    for idx in range(j - 1, i - 1, -1):
        X_baru[idx] = X[idx - 1]  # Geser nilai gen ke kiri

    X_baru[i - 1] = gen_yang_disisipkan  # Sisipkan nilai gen sebelum indeks i
    return X_baru

def reversion(X, i, j):
    X_baru = X.copy()
    subsequence = X[i-1:j][::-1]  # Ambil sublist dari i hingga j dan balik urutannya

    for idx, value in enumerate(subsequence):
        X_baru[i-1 + idx] = value  # Masukkan nilai dari sublist ke dalam array baru
    return X_baru

def scramble(X, i, j):
    X_baru = X.copy()
    k_acak = np.random.choice(range(i, j + 1), j - i + 1, replace=False)  # Pilih bilangan acak dari i hingga j

    for idx, k in enumerate(k_acak):
        X_baru[i + idx] = X[k]
    return X_baru

# Define the PMX (Partially Mapped Crossover) function
def pmx(parent1, parent2, slice_index1, slice_index2):
    if len(parent1) != len(parent2):
        raise ValueError('Parents have not the same length!')

    child1 = parent1.copy()
    child2 = parent2.copy()
    mapping1 = {}
    mapping2 = {}

    # Map Slice
    for i in range(slice_index1, slice_index2 + 1):
        mapping1[parent2[i]] = parent1[i]
        child1[i] = parent2[i]

        mapping2[parent1[i]] = parent2[i]
        child2[i] = parent1[i]

    # Repair Lower Slice
    for i in range(slice_index1):
        while child1[i] in mapping1:
            child1[i] = mapping1[child1[i]]
        while child2[i] in mapping2:
            child2[i] = mapping2[child2[i]]

    # Repair Upper Slice
    for i in range(slice_index2 + 1, len(child1)):
        while child1[i] in mapping1:
            child1[i] = mapping1[child1[i]]
        while child2[i] in mapping2:
            child2[i] = mapping2[child2[i]]

    return child1, child2

# Define the Ordered Crossover (OX) function
def ox(parent1, parent2, start, end):
    """Implements ordered crossover"""
    size = len(parent1)

    # Replicate parent1's sequence for offspring1, parent2's sequence for offspring2
    offspring1, offspring2 = [-1] * size, [-1] * size
    for i in range(start, end + 1):
        offspring1[i] = parent1[i]
        offspring2[i] = parent1[i]

    # Fill the remaining positions with the other parents' entries
    current_parent2_position, current_parent1_position = 0, 0
    for i in range(size):
        if i in range(start, end + 1):
            continue

        # Ensure current_parent2_position doesn't exceed bounds
        while current_parent2_position < size and parent2[current_parent2_position] in offspring1:
            current_parent2_position += 1

        # Ensure current_parent1_position doesn't exceed bounds
        while current_parent1_position < size and parent1[current_parent1_position] in offspring2:
            current_parent1_position += 1

        if current_parent2_position < size:
            offspring1[i] = parent2[current_parent2_position]

        if current_parent1_position < size:
            offspring2[i] = parent1[current_parent1_position]

    return offspring1, offspring2

# Function to select a random operator
def select_operator():
    operators = ['Swap', 'Insertion', 'Reversion', 'Scramble']
    probabilities = [0.25, 0.25, 0.25, 0.25]  # Probabilitas pemilihan operator
    return np.random.choice(operators, p=probabilities)

# Function to select a crossover operator
def select_crossover_operator():
    crossover_operators = ['PMX', 'OX']
    probabilities = [0.5, 0.5]  # Probabilities for crossover operators
    return np.random.choice(crossover_operators, p=probabilities)

# Function to split routes into exactly numvehicle considering the vehicle capacity
def split_routes(route, demands, vehicle_capacity, numvehicle):
    sub_routes = []
    current_route = [depot]
    current_load = 0

    for node in route:
        if current_load + demands[node] <= vehicle_capacity:
            current_route.append(node)
            current_load += demands[node]
        else:
            current_route.append(depot)
            sub_routes.append(current_route)
            current_route = [depot, node]
            current_load = demands[node]
    current_route.append(depot)
    sub_routes.append(current_route)

    return sub_routes

# Track the best split solution and its total cost
best_split_solution = None
best_split_cost = float('inf')
best_route = None

# Track if there's an improvement in the best solution
last_improvement_iteration = 0

# Run the simulated annealing process for max_iterations
for iteration in range(max_iterations):
    for route_index in range(len(current_solution)):
        best_local_solution = np.copy(current_solution[route_index])
        best_local_split_solution = split_routes(best_local_solution, demands, vehicle_capacity, numvehicle)
        best_local_cost = sum(calculate_route_distance(route) for route in best_local_split_solution)

        for _ in range(100):  # Apply random operator 100 times
            neighbor_solution = np.copy(best_local_solution)
            operator = select_operator()

            if operator == 'Swap':
                neighbor_solution = swap_operator(neighbor_solution)
            elif operator == 'Insertion':
                i, j = sorted(np.random.choice(len(neighbor_solution), 2, replace=False))
                neighbor_solution = insertion(neighbor_solution, i, j)
            elif operator == 'Reversion':
                i, j = sorted(np.random.choice(len(neighbor_solution), 2, replace=False))
                neighbor_solution = reversion(neighbor_solution, i, j)
            elif operator == 'Scramble':
                i, j = sorted(np.random.choice(len(neighbor_solution), 2, replace=False))
                neighbor_solution = scramble(neighbor_solution, i, j)

            neighbor_split_solution = split_routes(neighbor_solution, demands, vehicle_capacity, numvehicle)
            neighbor_cost = sum(calculate_route_distance(route) for route in neighbor_split_solution)
            delta_cost = neighbor_cost - best_local_cost

            if delta_cost < 0:
                best_local_solution = neighbor_solution
                best_local_split_solution = neighbor_split_solution
                best_local_cost = neighbor_cost
            else:
                if np.random.rand() < np.exp(-delta_cost / temperature):
                    best_local_solution = neighbor_solution
                    best_local_split_solution = neighbor_split_solution
                    best_local_cost = neighbor_cost

        current_solution[route_index] = best_local_solution
        current_costs[route_index] = best_local_cost

    # Apply crossover after the local optimization
    for _ in range(30):
        if np.random.rand() < crossover_probability:
            parent_indices = list(range(len(current_solution)))
            np.random.shuffle(parent_indices)  # Shuffle the indices to randomize parent selection
        for i in range(0, len(parent_indices), 2):
                if i + 1 >= len(parent_indices):
                    break

                parent1_index = parent_indices[i]
                parent2_index = parent_indices[i + 1]

                parent1 = current_solution[parent1_index]
                parent2 = current_solution[parent2_index]

                crossover_operator = select_crossover_operator()

                if crossover_operator == 'PMX':
                    slice_index1, slice_index2 = sorted(np.random.choice(len(parent1), 2, replace=False))
                    child1, child2 = pmx(parent1, parent2, slice_index1, slice_index2)
                elif crossover_operator == 'OX':
                    start, end = sorted(np.random.choice(len(parent1), 2, replace=False))
                    child1, child2 = ox(parent1, parent2, start, end)

                # Evaluate children and select the best
                child1_split_solution = split_routes(child1, demands, vehicle_capacity, numvehicle)
                child2_split_solution = split_routes(child2, demands, vehicle_capacity, numvehicle)

                child1_cost = sum(calculate_route_distance(route) for route in child1_split_solution)
                child2_cost = sum(calculate_route_distance(route) for route in child2_split_solution)

                # Check if children are better
                if child1_cost < current_costs[parent1_index]:
                    current_solution[parent1_index] = child1
                    current_costs[parent1_index] = child1_cost
                if child2_cost < current_costs[parent2_index]:
                    current_solution[parent2_index] = child2
                    current_costs[parent2_index] = child2_cost


    # Selection method applied on the second half of iterations if no improvement in the last 10% iterations
    if iteration > max_iterations * 0.5 or iteration - last_improvement_iteration > max_iterations * 0.1 :
      # Compute total costs with depot included for each solution
        total_costs_with_depot = []
        for route in current_solution:
            split_solution = split_routes(route, demands, vehicle_capacity, numvehicle)
            total_cost = sum(calculate_route_distance(sub_route) for sub_route in split_solution)
            total_costs_with_depot.append(total_cost)

        # Sort population based on total costs with depot
        sorted_indices = np.argsort(total_costs_with_depot)
        best_half = sorted_indices[:population_size // 2]
        worst_half = sorted_indices[population_size // 2:]

        # Replace the worst half with the best half
        current_solution[worst_half] = current_solution[best_half]
        current_costs[worst_half] = current_costs[best_half]

        # Generate new random solutions to replace the second half of the worst half
        for i in range(population_size // 2, population_size):
            route = np.random.permutation(len(nodes) - 1) + 1  # Assuming nodes start from 1 and exclude depot (0)
            current_solution[i] = route
            current_costs[i] = objective_function(route)

    # Update the global best solution
    best_solution_index = np.argmin(current_costs)
    if current_costs[best_solution_index] < best_cost:
        best_solution = np.copy(current_solution[best_solution_index])
        best_cost = current_costs[best_solution_index]
        last_improvement_iteration = iteration

    # Cooling schedule: Decrease temperature
    temperature = cooling_rate * temperature

    # Split and evaluate all solutions in the population
    for route_index in range(len(current_solution)):
        split_solution = split_routes(current_solution[route_index], demands, vehicle_capacity, numvehicle)
        total_cost = sum(calculate_route_distance(route) for route in split_solution)

        # Check if this split solution is the best
        if total_cost < best_split_cost:
            best_split_solution = split_solution
            best_split_cost = total_cost
            best_route = current_solution[route_index]

    # Print current solutions and split routes
    print(f"Iteration {iteration + 1}")
    for idx, route in enumerate(current_solution):
        print(f"Route {idx}: {route} with cost {current_costs[idx]}")

    print("Split routes and costs for all solutions:")
    for route_index, route in enumerate(current_solution):
        split_solution = split_routes(route, demands, vehicle_capacity, numvehicle)
        total_cost = sum(calculate_route_distance(route) for route in split_solution)
        print(f"Solution {route_index + 1} split routes:")
        for i, vehicle_route in enumerate(split_solution):
            print(f"  Vehicle {i + 1} route: {vehicle_route} with cost {calculate_route_distance(vehicle_route)}")
        print(f"  Total cost: {total_cost}")

# Output the results
print("Best solution (node sequence):", best_route)
print("Best cost without depot:", best_cost)
print("Routes for each vehicle with depot:")
for i, vehicle_route in enumerate(best_split_solution):
    print(f"Vehicle {i + 1} route: {vehicle_route} with cost {calculate_route_distance(vehicle_route)}")
print("Total cost with depot for all vehicles:", best_split_cost)
print("Final temperature:", temperature)

def plot_routes(best_split_solution, coordinates, depot):
    plt.figure(figsize=(10, 10))
    colors = plt.cm.get_cmap('tab10', numvehicle)

    for i, route in enumerate(best_split_solution):
        route_coords = coordinates[route]
        plt.plot(route_coords[:, 0], route_coords[:, 1], marker='o', color=colors(i), label=f'Vehicle {i + 1}')
        plt.scatter(route_coords[0, 0], route_coords[0, 1], color='red', marker='s', s=100)  # Depot

        # Add node numbers
        for idx, node in enumerate(route):
            plt.text(route_coords[idx, 0], route_coords[idx, 1], str(node), fontsize=12, color='black', ha='right')

    plt.xlabel('X Coordinate')
    plt.ylabel('Y Coordinate')
    plt.title('Routes for Each Vehicle')
    plt.legend()
    plt.grid(True)
    plt.show()

# Call the function to plot the routes
plot_routes(best_split_solution, coordinates, depot)